# Empower1 Interoperability: Cross-Chain Atomic Swaps (Conceptual Design)

## 1. Introduction

Interoperability refers to the ability of different blockchain networks to exchange information and value seamlessly. For Empower1, achieving interoperability is crucial for connecting with broader blockchain ecosystems, enhancing the utility of its native assets and tokens, and fostering wider adoption.

**Atomic Swaps** are a mechanism that enables the trustless exchange of cryptocurrencies residing on different blockchains without relying on a centralized intermediary or custodian. The "atomic" nature ensures that the swap either completes successfully for both parties or fails entirely, with no risk of one party losing their funds if the other party defaults.

This document focuses on **Hashed TimeLock Contracts (HTLCs)** as the primary mechanism for implementing cross-chain atomic swaps involving the Empower1 blockchain.

## 2. Hashed TimeLock Contracts (HTLCs) Explained

### 2.1. Core Concept
An HTLC is a type of smart contract or script that facilitates conditional, time-bound transactions. It locks assets and allows them to be claimed only if a specific condition (revealing a secret) is met within a certain timeframe. If the condition is not met within the timeframe, the assets can be reclaimed by the original owner. This mechanism ensures atomicity in trades.

### 2.2. Key Components

*   **Secret (Preimage `S`):** A unique, random piece of data (e.g., a large random number) generated by one party (the initiator of the swap).
*   **Hashlock (Hash `H`):** The result of applying a cryptographic hash function (e.g., SHA256) to the secret `S`. `H = sha256(S)`. Funds are locked such that they can only be spent by someone who can provide `S` (which hashes to `H`).
*   **Timelock (Refund Deadline):** A condition defining a specific point in time (or block height) after which funds can be reclaimed by the original depositor if they haven't been claimed by the counterparty. This prevents funds from being locked indefinitely.
    *   `lock_time_A`: The deadline by which Party B must redeem Asset 1 from Party A's HTLC on Chain 1. After this time, Party A can reclaim Asset 1.
    *   `lock_time_B`: The deadline by which Party A must redeem Asset 2 from Party B's HTLC on Chain 2. After this time, Party B can reclaim Asset 2. *Crucially, `lock_time_B` must be significantly shorter than `lock_time_A`.*

### 2.3. Typical HTLC Workflow (Two-Phase Commit)

Let's say Party A wants to trade Asset 1 (on Chain 1, e.g., Empower1) for Party B's Asset 2 (on Chain 2, e.g., Bitcoin or another compatible chain).

**Phase 1: Setup & Initiation (Party A initiates)**
1.  **Secret Generation:** Party A generates a secret `S` and computes its hash `H = sha256(S)`.
2.  **HTLC Deployment on Chain 1:** Party A deploys an HTLC on Chain 1 (Empower1). This contract locks Party A's Asset 1 and includes the following conditions:
    *   Party B can redeem Asset 1 by providing the secret `S` (such that `sha256(S) == H`) **before** `lock_time_A`.
    *   Party A can reclaim (refund) Asset 1 if Party B does not redeem it **after** `lock_time_A` has expired.
3.  **Communication:** Party A communicates the hash `H` (but **not** the secret `S`) to Party B, along with details of the HTLC on Chain 1 (e.g., contract address or swap identifier).

**Phase 2: Counterparty Setup & Redemption (Party B responds)**
1.  **Verification:** Party B verifies Party A's HTLC on Chain 1 to ensure it's correctly set up with the agreed terms (amount, hash `H`, `lock_time_A`, recipient).
2.  **HTLC Deployment on Chain 2:** Party B deploys a corresponding HTLC on Chain 2. This contract locks Party B's Asset 2 and specifies:
    *   Party A can redeem Asset 2 by providing the same secret `S` (such that `sha256(S) == H`) **before** `lock_time_B`.
    *   Party B can reclaim (refund) Asset 2 if Party A does not redeem it **after** `lock_time_B` has expired.
    *   **Timing Criticality:** `lock_time_B` must be shorter than `lock_time_A` (e.g., if `lock_time_A` is 48 hours, `lock_time_B` might be 24 hours). This gives Party A enough time to redeem on Chain 2 and then for Party B to use the revealed secret on Chain 1.
3.  **Redemption by Party A (on Chain 2):** Party A monitors Chain 2. Once Party B's HTLC is active, Party A redeems Asset 2 by calling the HTLC and providing the secret `S`. This action reveals `S` publicly on Chain 2.
4.  **Redemption by Party B (on Chain 1):** Party B monitors Chain 2 (or is notified by Party A). Once `S` is revealed, Party B uses this `S` to redeem Asset 1 from Party A's HTLC on Chain 1. This must be done before `lock_time_A` expires.

**Atomicity & Refund Scenarios:**
*   **Successful Swap:** If both parties act correctly, Party A gets Asset 2, and Party B gets Asset 1. The swap is complete.
*   **Party A Fails to Redeem on Chain 2:** If Party A does not redeem Asset 2 from Party B's HTLC before `lock_time_B`, Party B can reclaim their Asset 2 after `lock_time_B` expires. Since `S` was not revealed, Party B cannot claim Asset 1 from Party A. Party A can then reclaim Asset 1 from their own HTLC after `lock_time_A` expires. No funds are lost, only time and transaction fees.
*   **Party B Fails to Redeem on Chain 1:** If Party A redeems Asset 2 (revealing `S`), but Party B fails to use `S` to redeem Asset 1 before `lock_time_A`, Party A reclaims Asset 1 after `lock_time_A`. In this scenario, Party A ends up with both their original Asset 1 and Party B's Asset 2 (minus fees). This is why Party B is incentivized to act once `S` is known. However, the atomicity of "swap or no swap" holds from the perspective that if one part fails before secret reveal, the other part also allows refund.

## 3. Implementing Atomic Swaps on Empower1

### 3.1. Preferred Approach: Smart Contract-Based HTLCs
Given Empower1's WASM smart contract capabilities, the most flexible and feature-rich way to implement atomic swaps is by creating a standard HTLC smart contract template.

### 3.2. `AtomicSwap.as` Contract Interface (Conceptual AssemblyScript)
A potential interface for an `AtomicSwap.as` contract on Empower1:

*   **`initiateSwap(hashedSecret: bytes, recipientAddress: string, tokenContractAddress: string | null, amount: u64, lockTimeAbsolute: u64): string (swapId)`**
    *   Called by the initiator (Party A on Empower1).
    *   `hashedSecret`: The SHA256 hash `H` of the secret `S`. (Type `bytes` likely `ArrayBuffer` in AS, passed as ptr/len by host).
    *   `recipientAddress`: The Empower1 address of Party B (who can redeem).
    *   `tokenContractAddress`: If swapping an ETRC20 token, this is its address. If `null` or a specific value, it implies the native Empower1 coin.
    *   `amount`: The amount of Asset 1 to lock.
    *   `lockTimeAbsolute`: The absolute block height or Unix timestamp for the lock expiry.
    *   **Logic:**
        *   Validates parameters.
        *   Generates a unique `swapId` (e.g., hash of initiator, recipient, hashedSecret, nonce).
        *   If ETRC20: Calls `transferFrom` on the `tokenContractAddress` to pull tokens into this HTLC contract (requires prior approval from Party A to the HTLC contract).
        *   If native coin: Locks the native coins (requires the contract to be able to hold native coins, or for the node to manage this via a special mechanism tied to the contract).
        *   Stores `swapId -> { hashedSecret, recipientAddress, originalSenderAddress, tokenContractAddress, amount, lockTimeAbsolute, status: "OPEN" }`.
        *   Emits `SwapInitiated(swapId: string, initiator: string, recipient: string, asset: string, amount: u64, hashedSecret: string, lockTime: u64)`.
    *   **Returns:** The unique `swapId` string.

*   **`redeemSwap(swapId: string, secret: bytes): bool`**
    *   Called by the redeemer (Party B on Empower1, or Party A if Empower1 is Chain 2).
    *   `secret`: The preimage `S`.
    *   **Logic:**
        *   Retrieves swap details using `swapId`.
        *   Verifies swap status is "OPEN".
        *   Verifies `sha256(secret)` matches the stored `hashedSecret`.
        *   Verifies current block time/height is **before** `lockTimeAbsolute`.
        *   Verifies the caller is the designated `recipientAddress` (or, if Empower1 is Chain 2, the original initiator of the *overall* swap, who is now the recipient on *this specific* HTLC).
        *   Transfers the locked assets (native or ETRC20) to the caller.
        *   Updates swap status to "REDEEMED".
        *   Emits `SwapRedeemed(swapId: string, redeemer: string, secret: string)`.
    *   **Returns:** `true` on success, `false` on failure.

*   **`refundSwap(swapId: string): bool`**
    *   Called by the original initiator of this specific HTLC if `lockTimeAbsolute` has passed and the swap was not redeemed.
    *   **Logic:**
        *   Retrieves swap details.
        *   Verifies swap status is "OPEN".
        *   Verifies current block time/height is **after** `lockTimeAbsolute`.
        *   Verifies the caller is the original initiator of this HTLC.
        *   Returns the locked assets to the original initiator.
        *   Updates swap status to "REFUNDED".
        *   Emits `SwapRefunded(swapId: string)`.
    *   **Returns:** `true` on success, `false` on failure.

*   **`getSwapDetails(swapId: string): string | null` (View Function)**
    *   Returns a JSON string of the swap's details (initiator, recipient, amount, asset, lock time, status, hashed secret) or `null` if not found.

### 3.3. Supported Assets
*   **Native Empower1 Coin:** Requires the HTLC contract or the underlying system to be able to escrow native coins.
*   **ETRC20 Tokens:** Tokens deployed on Empower1 that adhere to a standard interface (e.g., `transfer`, `transferFrom`, `approve`). The HTLC would use `transferFrom` to pull tokens after user approval.

### 3.4. Hashing Algorithm
*   **SHA256:** Standardize on SHA256 for the secret hash `H` for broad interoperability with other blockchains.

## 4. Hypothetical Cross-Chain Scenario: Empower1 ETRC20 Token for Bitcoin

*   **Alice:** Has ETRC20 tokens on Empower1. Wants Bitcoin.
*   **Bob:** Has Bitcoin (BTC). Wants Alice's ETRC20 tokens.

1.  **Alice (Secret Generation):** Generates secret `S`, calculates `H = sha256(S)`.
2.  **Alice (Empower1 - Initiate):**
    *   Approves the `AtomicSwap.as` contract to spend her ETRC20 tokens.
    *   Calls `AtomicSwap.as::initiateSwap(H, Bob_Empower1_Address, Alice_ETRC20_Token_Address, amount_ETRC20, lockTime_Alice_Empower1)`. Gets `swapId_Empower1`.
3.  **Alice to Bob (Communication):** Sends `H` and `swapId_Empower1` to Bob.
4.  **Bob (Bitcoin - Initiate):**
    *   Verifies Alice's HTLC on Empower1 (e.g., using `getSwapDetails(swapId_Empower1)` via an Empower1 node/explorer).
    *   Creates a Bitcoin HTLC script locking his BTC. This script includes:
        *   Redeemable by Alice's Bitcoin public key if `S` (matching `H`) is provided before `lockTime_Bob_Bitcoin`.
        *   Refundable to Bob after `lockTime_Bob_Bitcoin`.
        *   `lockTime_Bob_Bitcoin` must be shorter than `lockTime_Alice_Empower1`.
5.  **Alice (Bitcoin - Redeem):**
    *   Observes Bob's HTLC on the Bitcoin blockchain.
    *   Broadcasts a Bitcoin transaction that includes `S` to redeem the BTC. `S` is now public on the Bitcoin chain.
6.  **Bob (Empower1 - Redeem):**
    *   Observes `S` from the Bitcoin blockchain.
    *   Calls `AtomicSwap.as::redeemSwap(swapId_Empower1, S)` on Empower1 to claim the ETRC20 tokens before `lockTime_Alice_Empower1` expires.

## 5. Security Considerations & Challenges

*   **Atomicity Guarantee:** HTLCs ensure that if one party defaults or fails (e.g., network issues, client crashes), the other party can safely reclaim their funds after their respective timelock expires.
*   **Timelock Selection:** This is critical. The timelock for the second HTLC (Party B's) must be significantly shorter than the timelock for the first HTLC (Party A's). This window must account for:
    *   Time for Party A to see Party B's HTLC and redeem it.
    *   Time for the transaction revealing `S` (Party A's redemption on Chain 2) to achieve sufficient finality on Chain 2.
    *   Time for Party B to observe `S` on Chain 2 and then create, broadcast, and get their redemption transaction confirmed on Chain 1.
    *   Potential block confirmation times and chain reorganization depths on both chains.
*   **Secret Management:** The initiator (Party A) must safeguard `S` until they have successfully redeemed from Party B's HTLC. Premature revelation without redeeming could allow Party B to claim funds on Chain 1 without having their own funds claimed.
*   **Transaction Fees:** Users will pay transaction fees on both blockchains for deploying HTLCs and for redeeming or refunding them. These costs need to be considered.
*   **Chain Reorganizations:** A chain reorg on Chain 2 after Party A reveals `S` but before Party B sees it could be problematic. Party A might have redeemed, but `S` is no longer visible for Party B. Longer confirmation requirements for redemption transactions help mitigate this.
*   **Compatibility:** Both participating blockchains must have the necessary scripting or smart contract capabilities to implement HTLC logic (hashing, timelocks, conditional transfers, signature verification).

## 6. Conclusion

HTLCs, implemented via smart contracts like the proposed `AtomicSwap.as` on Empower1, provide a robust and well-understood mechanism for achieving trustless cross-chain atomic swaps. This would significantly enhance Empower1's interoperability, allowing its native assets and ETRC20 tokens to be traded with assets on other compatible blockchains.

Future work would involve:
*   Developing and rigorously testing the `AtomicSwap.as` smart contract.
*   Ensuring the Empower1 host function API provides all necessary primitives (especially for token interactions like `approve`/`transferFrom` if not directly available to contracts, and reliable block time/height for timelocks).
*   Developing user-friendly tooling (e.g., updates to the CLI wallet and JS SDK) to facilitate the creation, management, and execution of atomic swaps for end-users.
*   Establishing clear guidelines for timelock durations considering Empower1's block time and finality characteristics relative to other chains.
