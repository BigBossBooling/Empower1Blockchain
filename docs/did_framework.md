# Decentralized Identifiers (DIDs) in Empower1

This document outlines the framework for supporting Decentralized Identifiers (DIDs) on the Empower1 blockchain. The initial focus is on the `did:key` method and a smart contract-based registry for anchoring DID documents.

## 1. Introduction to DIDs

Decentralized Identifiers (DIDs) are a new type of identifier that enables verifiable, decentralized digital identity. A DID refers to a subject and is associated with a DID Document that contains metadata such as cryptographic public keys, service endpoints, and other attributes related to the DID subject.

## 2. DID Method: `did:key`

The `did:key` method is chosen as the foundational DID method for Empower1. It provides a simple, direct way to create a DID from a cryptographic public key.

*   **Format:** The standard format is `did:key:<multibase-multicodec-public-key-string>`.
    *   Empower1 uses ECDSA with the SECP256R1 (P-256) curve. An uncompressed public key (0x04 + X + Y, 65 bytes) is used.
    *   **Multicodec Prefix for P-256 Uncompressed Public Key:** `0x1201`. This two-byte prefix indicates an uncompressed P-256 public key. (Note: standard multicodec prefixes can evolve; `0x1201` is selected for P256 public keys based on some drafts/interpretations for uncompressed keys. Another common one for general secp256r1 is `0xe7` for the key in general, but `did:key` often uses more specific ones or implies it from context. `zQ3s` multibase prefix implies a P256 key usually.)
    *   **Construction:**
        1.  Take the raw uncompressed public key bytes (65 bytes, starting with `0x04`).
        2.  Prepend the multicodec prefix: `0x1201` + `pubKeyBytes`. This results in a 67-byte sequence.
        3.  Encode this 67-byte sequence using Base58BTC (Bitcoin base58 alphabet).
        4.  Prepend the multibase prefix for Base58BTC, which is `z`.
    *   **Resulting `did:key` string:** `did:key:z<base58btc_encoded_string>` (e.g., `did:key:zQ3sX4b5v2...`).

*   **Blockchain Identifier:** We will stick to the standard `did:key` method format. This promotes interoperability. The Empower1 blockchain will act as a verifiable data registry where additional information or documents related to a `did:key` can be anchored using the `DIDRegistry` smart contract.

## 3. DID Document Anchoring & `DIDRegistry` Smart Contract

While `did:key` directly implies a DID Document containing mainly the public key, users often need a more comprehensive DID Document with additional service endpoints, authentication methods, etc. These extended DID Documents are typically stored off-chain (e.g., on IPFS, a web server, or other decentralized storage).

The `DIDRegistry` smart contract links a `did:key` to its corresponding off-chain DID Document.

*   **Purpose:**
    *   To associate a `did:key` with the location (URI) and an integrity hash of its comprehensive DID Document.
    *   To provide a discoverable, on-chain record of this association.

*   **Smart Contract Interface (`DIDRegistry.as`):**

    *   **`registerDIDDocument(did_to_register: string, document_hash: string, document_location_uri: string): void`**
        *   **Description:** Registers or updates the hash and URI for a DID Document associated with the given `did_to_register`.
        *   **Authentication:** This function MUST be called by a transaction signed by the private key corresponding to the public key embedded in the `did_to_register`. The contract verifies this by:
            1.  Calling a host function `blockchain_get_caller_public_key()` to retrieve the raw public key bytes of the transaction signer.
            2.  Calling another host function `blockchain_generate_did_key(caller_pub_key_bytes)` which takes these raw public key bytes, constructs the expected `did:key` string (e.g., `did:key:zQ3s...`) using the same multicodec/multibase logic as clients.
            3.  Comparing the `did_to_register` argument with the `did:key` string generated by the host from the caller's public key. If they match, the registration proceeds.
        *   **Storage:** Stores `did_to_register -> { document_hash, document_location_uri }`.
        *   **Event:** Emits `DIDDocumentRegistered(did: string, document_hash: string, document_uri: string)`.

    *   **`getDIDDocumentInfo(did_string: string): string | null`**
        *   **Description:** Retrieves the stored hash and URI for a given `did_string`.
        *   **Returns:** A JSON string `"{ "document_hash": "...", "document_location_uri": "..." }"` or `null` if not found.

    *   **`getDIDDocumentHash(did_string: string): string | null`**
        *   **Description:** Retrieves only the document hash for a given `did_string`.
        *   **Returns:** The hash string or `null`.

    *   **`getDIDDocumentURI(did_string: string): string | null`**
        *   **Description:** Retrieves only the document URI for a given `did_string`.
        *   **Returns:** The URI string or `null`.

    *   **`revokeDIDDocument(did_to_revoke: string): void`** (Future Enhancement)
        *   **Description:** Removes the association for a DID Document. Requires authentication similar to `registerDIDDocument`.

## 4. Authentication and Authorization

*   **DID Control:** Control over a `did:key` is defined by control over the associated private key.
*   **Registry Operations:** State-changing operations on the `DIDRegistry` are authorized by verifying that the transaction signer's derived `did:key` matches the DID being managed (e.g., the `did_to_register` or `did_to_revoke`). This is done within the contract using host functions that provide the caller's public key and a utility to generate the `did:key` string from it.

## 5. Host Function Requirements (for Go implementation)

The `DIDRegistry` contract will require the following host functions provided by the Go environment:

*   **`blockchain_get_caller_public_key(ret_buf_ptr: i32, ret_buf_len: i32) -> i32`**:
    *   Writes the raw (uncompressed, 65-byte for P256) public key of the transaction signer into the WASM memory buffer provided by `ret_buf_ptr` and `ret_buf_len`.
    *   Returns the actual length of the public key written (should be 65), or an error code (e.g., if buffer is too small, or if caller is not identifiable as a single public key).
*   **`blockchain_generate_did_key(pubkey_ptr: i32, pubkey_len: i32, ret_buf_ptr: i32, ret_buf_len: i32) -> i32`**:
    *   Reads raw public key bytes (expected to be 65 bytes for P256 uncompressed) from WASM memory (at `pubkey_ptr` of `pubkey_len`).
    *   Generates the full `did:key:z...` string according to the defined multicodec (`0x1201`) / multibase (base58btc) scheme.
    *   Writes this string back into the WASM memory buffer at `ret_buf_ptr`.
    *   Returns the actual length of the `did:key` string written, or an error code (e.g., if buffer too small).
*   **`blockchain_emit_event(topic_ptr: i32, topic_len: i32, data_ptr: i32, data_len: i32): void`**:
    *   Emits an event with the given topic and data (both strings/byte arrays from WASM memory).
*   **Storage functions:** `blockchain_set_storage`, `blockchain_get_storage` (as previously designed).
*   **Logging function:** `host_log_message` (as previously designed).

## 6. CLI Wallet Integration

The `cli-wallet` is updated to support DID operations.

### Generating a `did:key`
Use the `did generate` command:
```bash
# Ensure you are in the cli-wallet directory and venv is active
python main.py did generate --wallet my_wallet.pem --password mypassword
```
This will output the `did:key` string associated with `my_wallet.pem`.

### Registering a DID Document
Use the `did register-document` command. This calls the `registerDIDDocument` function of the deployed `DIDRegistry` smart contract.
```bash
python main.py did register-document \
    --wallet my_wallet.pem --password mypassword \
    --did "did:key:zQ3sExampleDIDKeyMatchingMyWalletPem..." \
    --doc-hash "sha256_hash_of_your_did_document_content" \
    --doc-uri "ipfs://your_document_cid" \
    --contract-address "<hex_address_of_did_registry_contract>" \
    --node-url http://localhost:18001
```
*   The `--wallet` used for signing must correspond to the public key in the `--did` string. The command verifies this.
*   The node URL should point to the HTTP RPC endpoint of a running Empower1 node.

### Querying DID Document Information
Use the `did get-info` command. This calls the `getDIDDocumentInfo` function on the contract.
```bash
python main.py did get-info \
    --did "did:key:zQ3sExampleDIDKeyMatchingMyWalletPem..." \
    --contract-address "<hex_address_of_did_registry_contract>" \
    --node-url http://localhost:18001
```
This command currently uses the node's `/debug/call-contract` endpoint for simplicity as it's a read-only query. It will print the JSON string containing the document hash and URI, or null.
