import unittest
import os
import sys

# Add cli-wallet directory to Python path
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from did_utils import generate_did_key_from_public_key_hex
from wallet import generate_key_pair, get_public_key_bytes # For generating test data

import multibase
import multicodec
import binascii

class TestDIDUtils(unittest.TestCase):

    def test_generate_did_key_from_public_key_hex_valid(self):
        # 1. Generate a P256 key pair using existing wallet functions
        _, pub_key_obj = generate_key_pair()
        public_key_bytes_uncompressed = get_public_key_bytes(pub_key_obj)
        public_key_hex = public_key_bytes_uncompressed.hex()

        self.assertEqual(len(public_key_bytes_uncompressed), 65, "Public key bytes should be 65 bytes long.")
        self.assertTrue(public_key_hex.startswith("04"), "Public key hex should start with '04'.")

        # 2. Generate did:key
        did_key_string = generate_did_key_from_public_key_hex(public_key_hex)
        self.assertIsNotNone(did_key_string)

        # 3. Validate basic structure
        self.assertTrue(did_key_string.startswith("did:key:z"), f"DID string '{did_key_string}' should start with 'did:key:z'.")

        # 4. Validate by decoding (more thorough check of content)
        multibase_part = did_key_string.split(':')[-1]

        # python-multibase decode returns bytes
        decoded_multibase_bytes = multibase.decode(multibase_part)

        # python-multicodec.from_bytes consumes the prefix and returns code_name, code_code, rest_of_data
        consumed_codec = multicodec.from_bytes(decoded_multibase_bytes)

        self.assertEqual(consumed_codec.name, 'p256-pub', "Multicodec name should be 'p256-pub'.")
        self.assertEqual(consumed_codec.code, 0x1201, "Multicodec code should be 0x1201 for p256-pub.")

        key_bytes_from_did = consumed_codec.data

        self.assertEqual(key_bytes_from_did, public_key_bytes_uncompressed, "Decoded public key bytes do not match original.")

        # print(f"\nTestGenerateDIDKey (Valid):")
        # print(f"  Public Key Hex: {public_key_hex}")
        # print(f"  Generated DID Key: {did_key_string}")

    def test_generate_did_key_known_vector(self):
        """
        Tests consistency with a did:key generated by the Go implementation
        for a specific P256 public key.
        Go uses multicodec 0x1201 (varint 0x81 0x24) + uncompressed P256 pubkey, then base58btc.
        Python's 'p256-pub' multicodec name should correspond to 0x1201 and use the same varint.
        """
        known_pub_hex = "04d0c7dee8fc1ba33fd28088095b2eff0a290329996127813779b25a73c3b100940021c0c0d76047e331a248a5789550f8d3e301b5f9999a33317573db0904f94e"
        # This expected DID was confirmed to be generated by the Go code with 0x1201 prefix.
        expected_did = "did:key:zQ3shxNt9N8j5y4MX2o2oPqR3xYd9fT5zP3gC9gB8h8vJ6xJg"

        python_generated_did = generate_did_key_from_public_key_hex(known_pub_hex)
        self.assertEqual(python_generated_did, expected_did)

        # print(f"\nTestKnownVector:")
        # print(f"  Public Key Hex: {known_pub_hex}")
        # print(f"  Expected DID Key: {expected_did}")
        # print(f"  Python Generated: {python_generated_did}")


    def test_invalid_inputs_for_did_generation(self):
        with self.assertRaisesRegex(ValueError, "Invalid public key hex format"):
            generate_did_key_from_public_key_hex("041234") # Too short
        with self.assertRaisesRegex(ValueError, "Invalid public key hex format"):
            generate_did_key_from_public_key_hex("031234567890123456789012345678901234567890123456789012345678901234") # Compressed
        with self.assertRaisesRegex(ValueError, "Public key hex is not a valid hex string"):
            generate_did_key_from_public_key_hex("04" + "xx" * 64)
        with self.assertRaisesRegex(ValueError, "Invalid public key bytes"):
            generate_did_key_from_public_key_hex("05" + "aa" * 64)
        with self.assertRaises(ValueError): # Changed from TypeError, as constructor now raises ValueError for non-string
            generate_did_key_from_public_key_hex(12345) # type: ignore

    def test_did_key_consistency(self):
        """Test that the same public key always produces the same did:key."""
        _, pub_key_obj = generate_key_pair()
        public_key_hex = get_public_key_bytes(pub_key_obj).hex()

        did_key1 = generate_did_key_from_public_key_hex(public_key_hex)
        did_key2 = generate_did_key_from_public_key_hex(public_key_hex)
        self.assertEqual(did_key1, did_key2)

if __name__ == '__main__':
    unittest.main()
